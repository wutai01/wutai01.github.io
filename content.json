[{"title":"浏览器渲染机制","date":"2017-01-19T01:44:15.000Z","path":"2017/01/19/浏览器渲染机制/","text":"下面讨论一下浏览器的渲染机制，这里指的浏览器是chrome。总结如下几个概念：1、DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。2、CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。3、DOM 和 CSSOM 都是以 Bytes → characters → tokens → nodes → object model. 这样的方式生成最终的数据。 DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。4、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree，Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点。注意：display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 浏览器的渲染过程1.Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。注意：发起 js 文件的下载 request 并不需要 DOM 处理到那个 script 节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区。2.Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM3.Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。4.Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。5.Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。 以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。 实例：截图1截图2截图3截图4从上面的Timeline我们可以看出：首屏时间和DomContentLoad事件没有必然的先后关系所有CSS尽早加载是减少首屏时间的最关键js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。普通script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。","tags":[{"name":"web性能","slug":"web性能","permalink":"http://yoursite.com/tags/web性能/"}]},{"title":"vue cli配置说明","date":"2017-01-18T05:30:31.000Z","path":"2017/01/18/vue-cli配置说明/","text":"Vue-cli是vue官方提供的一个命令行工具(vue-cli),可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程从 package.json 中我们可以看到 “scripts”: { “dev”: “node build/dev-server.js”, “build”: “node build/build.js”, “lint”: “eslint –ext .js,.vue src”}当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js1.dev-server.js让我们先从 build/dev-server.js 入手,里面做了详细的注解。dev-server 2.webpack.dev.conf.js我们在 dev-server.js 中用到了 webpack.dev.conf.js 和 index.js，接下来看一下webpack.dev.confwebpack.dev.conf 3.webpack.base.conf.js我们看到在webpack.dev.conf.js中又引入了webpack.base.conf.js，它看起来很重要的样子，所以我们只能在下一章来看看 config/index.js了。webpack.base.conf 4.config/index.js终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.jsindex.js 中有 dev 和 production 两种环境的配置config/index.js 至此，我们的 npm run dev 讲完了。下面让我们来看一看执行 npm run build 5.build.jsbuild.js 6.webpack.prod.conf.jswebpack.prod.conf 至此 ～ 我们的 vue-cli webpack 配置就讲解完毕。","tags":[{"name":"webpack+vue","slug":"webpack-vue","permalink":"http://yoursite.com/tags/webpack-vue/"}]},{"title":"观察者模式理解与使用","date":"2017-01-16T09:51:00.000Z","path":"2017/01/16/观察者模式理解与使用/","text":"观察者模式优点： 1.时间上的解耦： 发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 2.对象上的解耦： 发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 var event = { clientList: [], listen: function( key, fn ){ if ( !this.clientList[ key ] ){ this.clientList[ key ] = []; } this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表 }, trigger: function(){ var key = Array.prototype.shift.call( arguments ), // (1); fns = this.clientList[ key ]; if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息 return false; } for( var i = 0, fn; fn = fns[ i++ ]; ){ fn.apply( this, arguments ); // (2) // arguments 是 trigger 时带上的参数 } }, remove: function( key, fn ){ var fns = this.clientList[ key ]; if ( !fns ){ // 如果 key 对应的消息没有被人订阅，则直接返回 return false; } if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; ( fns.length = 0 ); }else{ for ( var l = fns.length - 1; l &gt;=0; l– ){ // 反向遍历订阅的回调函数列表 var _fn = fns[ l ]; if ( _fn === fn ){ fns.splice( l, 1 ); // 删除订阅者的回调函数 } } } } }; var salesOffices = {}; var installEvent = function( obj ){ for ( var i in event ){ obj[ i ] = event[ i ]; } }; installEvent( salesOffices ); salesOffices.listen( ‘squareMeter88’, fn1 = function( price ){ // 小明订阅消息 console.log( ‘价格= ‘ + price ); }); salesOffices.listen( ‘squareMeter88’, fn2 = function( price ){ // 小红订阅消息 console.log( ‘价格= ‘ + price ); }); salesOffices.remove( ‘squareMeter88’, fn1 ); // 删除小明的订阅 salesOffices.trigger( ‘squareMeter88’, 2000000 ); // 输出：2000000 使用场景：参考：《设计模式与开发实践》","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"http://yoursite.com/tags/js设计模式/"}]},{"title":"helloWorld","date":"2017-01-16T09:50:39.000Z","path":"2017/01/16/helloWorld/","text":"基于hexo+github搭建的博客，挺好用的。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]