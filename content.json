[{"title":"微信小程序实践","date":"2018-02-23T06:20:59.000Z","path":"2018/02/23/微信小程序实践/","text":"最近头脑王者等小程序盛行，跟着这些热点，就搞了一个小程序（手速大作战），可以再微信小程序里搜来玩一玩。这小程序主要是用来导量的。 这是部分代码，包括了一个PK页面，详细我就不放了，有兴趣可以直接微信小程序搜索 手速大作战。 github Demo地址：https://github.com/wutai01/weChatSmallProgram 问题：1.频繁校验token会导致登陆失败，所以不需要每次请求都校验。2.loading 放到各个页面中。刚开始做了一个loading页面，每次跳转先跳loading，再监听完成跳转到相应页面。这样可以统一且保证所有初始化完成，但存在闪屏等诸多问题。最后还是修改成各个页面自己做加载loading。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"},{"name":"小程序","slug":"小程序","permalink":"http://yoursite.com/tags/小程序/"}]},{"title":"基于neplayer.js的video推流播放器","date":"2018-01-20T03:28:49.000Z","path":"2018/01/20/基于neplayer-js的video推流播放器/","text":"项目，微信扫描二维码（微信里的项目，必须要微信打开）： 播放器：1.直播播放器 video.vue2.视频播放器 historyVideo.vue 遇到的问题：1.自动播放，相关2.图片广告和直播流的相互切换3.离开后播放器的销毁","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"微信","slug":"微信","permalink":"http://yoursite.com/tags/微信/"}]},{"title":"分片上传实现","date":"2017-12-23T01:51:16.000Z","path":"2017/12/23/分片上传实现/","text":"分片上传 在更新宝项目中有大文件包上传的需求，为了防止文件过大所导致的上传超时的问题，所以进行分片上传。然后github那边找了一下，大致流程如下：第一步：按照 修改时间+文件名称+最后修改时间生成对应的MD5值第二步：跟服务端交互，校验文件的MD5值。如果存在相同的，那就说明文件已经存在（秒传)。并从后端返回得到分片的index数组（可以实现断点续传）。第三步：依次上传分片，上传参数 a. 分片数据（data），b. 总片数（total）， c.当前是第几片（index），d.当前这个包的MD5（fileMd5Value）第四步：通知服务端上传完成，请进行合并。 然后我这边因为不考虑续传，就直接省略了第二和第四步。 基于vue的mixins文件，sliceLoader.js服务端：upload.jsgithubuploadSlice","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"js堆栈","date":"2017-02-10T02:03:29.000Z","path":"2017/02/10/js堆栈/","text":"1、栈（stack）和堆（heap） stack为自动分配的内存空间，它由系统自动释放；而heap则是动态分配的内存，大小不定也不会自动释放。 2、基本类型和引用类型 基本类型：存放在栈内存中的简单数据段，数据大小确定，内存空间大小可以分配。 5种基本数据类型有Undefined、Null、Boolean、Number 和 String，它们是直接按值存放的，所以可以直接访问。 引用类型：存放在堆内存中的对象，变量实际保存的是一个指针，这个指针保存在栈中，指针指向另一个位置。每个空间大小不一样，要根据情况来进行特定的分配。 当我们需要访问引用类型（如对象，数组，函数等）的值时，首先从栈中获得该对象的地址指针，然后再从堆内存中取得所需的数据。","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"js事件模型和事件广播","date":"2017-02-10T01:47:55.000Z","path":"2017/02/10/js事件模型和事件广播/","text":"A.事件模型 大致实现思路就是创建一个类或是匿名函数，在bind和trigger函数外层作用域创建一个字典对象，用于存储注册的事件及响应函数列表， bind时，如果字典没有则创建一个，key是事件名称，value是数组，里面放着当前注册的响应函数，如果字段中有， 那么就直接push到数组即可。trigger时调出来依次触发事件响应函数即可。B.事件如何派发也就是事件广播（dispatchEvent） 一般我们在元素上绑定事件后，是靠用户在这些元素上的鼠标行为来捕获或者触发事件的，或者自带的浏览器行为事件， 比如click，mouseover，load等等，有些时候我们需要自定义事件或者在特定的情况下需要触发这些事件。 这个时候我们可以使用IE下fireEvent方法，高级浏览器（chrome,firefox等）有dispatchEvent方法。 ie下的例子： //document上绑定自定义事件ondataavailable document.attachEvent(‘ondataavailable’, function (event) { alert(event.eventType); }); var obj=document.getElementById(“obj”); //obj元素上绑定click事件 obj.attachEvent(‘onclick’, function (event) { alert(event.eventType); }); //调用document对象的createEventObject方法得到一个event的对象实例。 var event = document.createEventObject(); event.eventType = ‘message’; //触发document上绑定的自定义事件ondataavailable document.fireEvent(‘ondataavailable’, event); //触发obj元素上绑定click事件 document.getElementById(“test”).onclick = function () { obj.fireEvent(‘onclick’, event); }; 高级浏览器（chrome,firefox等）的例子： //document上绑定自定义事件ondataavailable document.addEventListener(‘ondataavailable’, function (event) { alert(event.eventType); }, false); var obj = document.getElementById(“obj”); //obj元素上绑定click事件 obj.addEventListener(‘click’, function (event) { alert(event.eventType); }, false); //调用document对象的 createEvent 方法得到一个event的对象实例。 var event = document.createEvent(‘HTMLEvents’); // initEvent接受3个参数： // 事件类型，是否冒泡，是否阻止浏览器的默认行为 event.initEvent(“ondataavailable”, true, true); event.eventType = ‘message’; //触发document上绑定的自定义事件ondataavailable document.dispatchEvent(event); var event1 = document.createEvent(‘HTMLEvents’); event1.initEvent(“click”, true, true); event1.eventType = ‘message’; //触发obj元素上绑定click事件 document.getElementById(“test”).onclick = function () { obj.dispatchEvent(event1); };","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"js中的事件流","date":"2017-02-10T01:34:46.000Z","path":"2017/02/10/js中的事件流/","text":"A.DOM2级事件处理程序: DOM2级事件模型中规定了事件流的三个阶段：捕获阶段、目标阶段、冒泡阶段，低版本IE（IE8及以下版本）不支持捕获阶段。 捕获事件流：Netscape提出的事件流，即事件由页面元素接收，逐级向下，传播到最具体的元素。 冒泡事件流：IE提出的事件流，即事件由最具体的元素接收，逐级向上，传播到页面。B.绑定事件： 1.W3C：target.addEventListener(event, listener, useCapture); event —— 事件类型；listener —— 事件触发时执行的函数；useCapture —— 指定事件是否在捕获或冒泡阶段执行， 为true时事件句柄在捕获阶段执行，为false（默认false）时，事件句柄在冒泡阶段执行。 btn.addEventListener(‘click’,function(){ //do something… },false) 对应的事件移除： removeEventListener(event,function,capture/bubble); 2.IE：target.attachEvent(type, listener); type - 字符串，事件名称，含“on”，比如“onclick”、“onmouseover”、“onkeydown”等。 listener —— 实现了 EventListener 接口或者是 JavaScript 中的函数。 btn.attachEvent(‘onclick’,function(){ //do something… }) 对应的事件移除： detachEvent(event,function);C.事件的委托（代理 Delegated Events）的原理以及优缺点: a：委托（代理）事件是那些被绑定到父级元素的事件，但是只有当满足一定匹配条件时才会被挪。这是靠事件的冒泡机制来实现的， 优点是： （1）可以大量节省内存占用，减少事件注册，比如在table上代理所有td的click事件就非常棒 （2）可以实现当新增子对象时无需再次对其绑定事件，对于动态内容部分尤为合适 缺点是： 事件代理的应用常用应该仅限于上述需求下，如果把所有事件都用代理就可能会出现事件误判，即本不应用触发事件的被绑上了事件。 原生js实现事件代理，并要求兼容浏览器: function delegateEvent(interfaceEle, selector, type, fn) { if(interfaceEle.addEventListener){ interfaceEle.addEventListener(type, eventfn); }else{ interfaceEle.attachEvent(“on”+type, eventfn); } function eventfn(e){ var e = e || window.event; var target = e.target || e.srcElement; if (matchSelector(target, selector)) { if(fn) { fn.call(target, e); } } } } function matchSelector(ele, selector) { if (selector.charAt(0) === “#”) { return ele.id === selector.slice(1); } if (selector.charAt(0) === “.”) { return (“ “ + ele.className + “ “).indexOf(“ “ + selector.slice(1) + “ “) != -1; } return ele.tagName.toLowerCase() === selector.toLowerCase(); } //调用 var odiv = document.getElementById(“oDiv”); delegateEvent(odiv,”a”,”click”,function(){ alert(“1”); })","tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"浏览器渲染机制","date":"2017-01-19T01:44:15.000Z","path":"2017/01/19/浏览器渲染机制/","text":"下面讨论一下浏览器的渲染机制，这里指的浏览器是chrome。总结如下几个概念：1、DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。2、CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。3、DOM 和 CSSOM 都是以 Bytes → characters → tokens → nodes → object model. 这样的方式生成最终的数据。 DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。4、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree，Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点。注意：display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。 浏览器的渲染过程1.Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。注意：发起 js 文件的下载 request 并不需要 DOM 处理到那个 script 节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区。2.Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM3.Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。4.Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。5.Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。 以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。 实例：从上面的Timeline我们可以看出：首屏时间和DomContentLoad事件没有必然的先后关系所有CSS尽早加载是减少首屏时间的最关键js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。普通script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。","tags":[{"name":"web性能","slug":"web性能","permalink":"http://yoursite.com/tags/web性能/"}]},{"title":"vue cli配置说明","date":"2017-01-18T05:30:31.000Z","path":"2017/01/18/vue-cli配置说明/","text":"Vue-cli是vue官方提供的一个命令行工具(vue-cli),可用于快速搭建大型单页应用。该工具提供开箱即用的构建工具配置，带来现代化的前端开发流程从 package.json 中我们可以看到 “scripts”: { “dev”: “node build/dev-server.js”, “build”: “node build/build.js”, “lint”: “eslint –ext .js,.vue src”}当我们执行 npm run dev / npm run build 时运行的是 node build/dev-server.js 或 node build/build.js1.dev-server.js让我们先从 build/dev-server.js 入手,里面做了详细的注解。dev-server 2.webpack.dev.conf.js我们在 dev-server.js 中用到了 webpack.dev.conf.js 和 index.js，接下来看一下webpack.dev.confwebpack.dev.conf 3.webpack.base.conf.js我们看到在webpack.dev.conf.js中又引入了webpack.base.conf.js，它看起来很重要的样子，所以我们只能在下一章来看看 config/index.js了。webpack.base.conf 4.config/index.js终于分析完了 webpack.base.conf.js，来让我们看一下 config/index.jsindex.js 中有 dev 和 production 两种环境的配置config/index.js 至此，我们的 npm run dev 讲完了。下面让我们来看一看执行 npm run build 5.build.jsbuild.js 6.webpack.prod.conf.jswebpack.prod.conf 至此 ～ 我们的 vue-cli webpack 配置就讲解完毕。","tags":[{"name":"webpack+vue","slug":"webpack-vue","permalink":"http://yoursite.com/tags/webpack-vue/"}]},{"title":"观察者模式理解与使用","date":"2017-01-16T09:51:00.000Z","path":"2017/01/16/观察者模式理解与使用/","text":"观察者模式优点： 1.时间上的解耦： 发布-订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案。比如，我们可以订阅 ajax 请求的 error、succ等事件。或者如果想在动画的每一帧完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，而只需要订阅感兴趣的事件发生点。 2.对象上的解耦： 发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外一个对象的某个接口。发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以自由地改变它们。 var event = { clientList: [], listen: function( key, fn ){ if ( !this.clientList[ key ] ){ this.clientList[ key ] = []; } this.clientList[ key ].push( fn ); // 订阅的消息添加进缓存列表 }, trigger: function(){ var key = Array.prototype.shift.call( arguments ), // (1); fns = this.clientList[ key ]; if ( !fns || fns.length === 0 ){ // 如果没有绑定对应的消息 return false; } for( var i = 0, fn; fn = fns[ i++ ]; ){ fn.apply( this, arguments ); // (2) // arguments 是 trigger 时带上的参数 } }, remove: function( key, fn ){ var fns = this.clientList[ key ]; if ( !fns ){ // 如果 key 对应的消息没有被人订阅，则直接返回 return false; } if ( !fn ){ // 如果没有传入具体的回调函数，表示需要取消 key 对应消息的所有订阅 fns &amp;&amp; ( fns.length = 0 ); }else{ for ( var l = fns.length - 1; l &gt;=0; l– ){ // 反向遍历订阅的回调函数列表 var _fn = fns[ l ]; if ( _fn === fn ){ fns.splice( l, 1 ); // 删除订阅者的回调函数 } } } } }; var salesOffices = {}; var installEvent = function( obj ){ for ( var i in event ){ obj[ i ] = event[ i ]; } }; installEvent( salesOffices ); salesOffices.listen( ‘squareMeter88’, fn1 = function( price ){ // 小明订阅消息 console.log( ‘价格= ‘ + price ); }); salesOffices.listen( ‘squareMeter88’, fn2 = function( price ){ // 小红订阅消息 console.log( ‘价格= ‘ + price ); }); salesOffices.remove( ‘squareMeter88’, fn1 ); // 删除小明的订阅 salesOffices.trigger( ‘squareMeter88’, 2000000 ); // 输出：2000000 使用场景：参考：《设计模式与开发实践》","tags":[{"name":"js设计模式","slug":"js设计模式","permalink":"http://yoursite.com/tags/js设计模式/"}]},{"title":"helloWorld","date":"2017-01-16T09:50:39.000Z","path":"2017/01/16/helloWorld/","text":"基于hexo+github搭建的博客，挺好用的。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]